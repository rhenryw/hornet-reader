<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Hornet Reader Simulator</title>
	<style>
		:root {
			color-scheme: light dark;
			font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
			background: Canvas;
			color: CanvasText;
		}

		body {
			margin: 0;
			min-height: 100vh;
			display: flex;
			flex-direction: column;
		}

		h1, h2, h3 {
			margin: 0;
			font-weight: 600;
		}

		select,
		input[type="color"],
		input[type="range"] {
			font: inherit;
		}

		main {
			flex: 1;
			display: grid;
			grid-template-columns: minmax(320px, 360px) 1fr;
			gap: 2rem;
			padding: clamp(1.5rem, 2vw + 1rem, 3rem);
			align-items: start;
			box-sizing: border-box;
		}

		@media (max-width: 900px) {
			main {
				grid-template-columns: 1fr;
			}
		}

		.panel {
			background: color-mix(in srgb, Canvas 92%, CanvasText 8%);
			border-radius: 20px;
			padding: 1.5rem;
			box-shadow: 0 1rem 3rem -1.5rem rgb(0 0 0 / 0.35);
		}

		.panel h2 {
			font-size: 1.35rem;
			margin-bottom: 0.75rem;
		}

		.hidden {
			display: none !important;
		}

		label {
			display: inline-flex;
			align-items: center;
			gap: 0.5rem;
			font-size: 0.95rem;
		}

		.setting {
			margin-bottom: 1.25rem;
		}

		input[type="range"] {
			width: 100%;
		}

		.color-samples {
			display: flex;
			gap: 0.5rem;
			align-items: center;
			margin-top: 0.75rem;
		}

		.color-chip {
			flex: 1;
			height: 2rem;
			border-radius: 999px;
			border: 1px solid rgb(0 0 0 / 0.15);
		}

		button {
			font: inherit;
			border-radius: 999px;
			border: none;
			padding: 0.65rem 1.5rem;
			cursor: pointer;
			background: linear-gradient(120deg, #5769ff, #ff4f7b);
			color: white;
			box-shadow: 0 0.75rem 1.5rem -1rem rgb(0 0 0 / 0.4);
			transition: transform 120ms ease, box-shadow 120ms ease;
		}

		button.ghost {
			background: transparent;
			color: inherit;
			border: 1px solid color-mix(in srgb, CanvasText 35%, Canvas 65%);
			box-shadow: none;
		}

		button:disabled {
			cursor: not-allowed;
			opacity: 0.6;
			box-shadow: none;
		}

		button:not(:disabled):hover {
			transform: translateY(-1px);
			box-shadow: 0 1rem 2rem -1.25rem rgb(0 0 0 / 0.6);
		}

		#sample {
			line-height: 1.65;
			font-size: clamp(1rem, 0.75rem + 0.5vw, 1.15rem);
			max-width: 70ch;
			margin: 1.25rem auto 0;
			padding: 1.5rem 1.75rem 3rem;
			border-radius: 20px;
			background: color-mix(in srgb, Canvas 96%, CanvasText 4%);
			min-height: 18rem;
			position: relative;
			overflow: visible;
		}

		#sample:focus-visible {
			outline: 3px solid color-mix(in srgb, #5769ff 45%, Canvas 55%);
			outline-offset: 6px;
		}

		#sample p {
			margin-bottom: 1.3rem;
		}

		.badge {
			display: inline-flex;
			align-items: center;
			gap: 0.5ch;
			font-size: 0.85rem;
			padding: 0.35rem 0.75rem;
			border-radius: 999px;
			background: color-mix(in srgb, CanvasText 12%, Canvas 88%);
		}

		#modeDescription {
			margin: -0.25rem 0 1.25rem;
			font-size: 0.85rem;
			color: color-mix(in srgb, CanvasText 65%, Canvas 35%);
		}

		header {
			display: flex;
			flex-wrap: wrap;
			justify-content: space-between;
			align-items: center;
			gap: 1rem;
			padding: clamp(1.25rem, 3vw, 2.25rem) clamp(1.5rem, 2vw + 1rem, 3rem) 0;
		}

		#gradientSizeValue {
			font-variant-numeric: tabular-nums;
		}

		.details {
			font-size: 0.9rem;
			color: color-mix(in srgb, CanvasText 60%, Canvas 40%);
			margin: 1rem 0 0;
		}

		footer {
			padding: 0  clamp(1.5rem, 2vw + 1rem, 3rem) 2rem;
			font-size: 0.85rem;
			color: color-mix(in srgb, CanvasText 55%, Canvas 45%);
		}

		.overlay-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
		}

		.line-band {
			position: absolute;
			left: -0.75rem;
			right: -0.75rem;
			height: var(--band-height, 2.25rem);
			border-radius: 12px;
		}

		.focus-window {
			position: absolute;
			left: 0;
			width: 100%;
			height: 3rem;
			background: color-mix(in srgb, #5769ff 14%, Canvas 86%);
			box-shadow: 0 10px 30px -20px rgba(0, 0, 0, 0.5);
			border-radius: 12px;
			opacity: 0.8;
		}

		.gutter-layer {
			position: absolute;
			top: 0;
			left: -2.5rem;
			width: 2rem;
			pointer-events: none;
		}

		.gutter-marker,
		.symbol-marker {
			position: absolute;
			width: 0.75rem;
			height: 0.75rem;
			border-radius: 50%;
			background: color-mix(in srgb, CanvasText 55%, Canvas 45%);
			opacity: 0.75;
		}

		.symbol-layer {
			position: absolute;
			top: 0;
			right: -2.25rem;
			width: 2rem;
			pointer-events: none;
		}

		.symbol-marker {
			border-radius: 0;
			width: auto;
			height: auto;
			font-size: 0.8rem;
			background: none;
			color: color-mix(in srgb, CanvasText 65%, Canvas 35%);
		}

		.chunk {
			display: inline-block;
			padding: 0.05em 0.1em;
		}

		.chunk-accent {
			background: color-mix(in srgb, #ff4f7b 20%, Canvas 80%);
			border-radius: 0.3em;
		}

		#sample.mode-column-gradient::before {
			content: "";
			position: absolute;
			top: 0;
			left: 0;
			width: var(--column-width, 1.25rem);
			height: 100%;
			background: linear-gradient(180deg, var(--column-color-start, #5769ff), var(--column-color-end, #ff4f7b));
			opacity: 0.75;
			pointer-events: none;
		}

		span.dimmed-line {
			opacity: 0.35;
		}

		span.active-line {
			opacity: 1;
		}

		.audio-indicator {
			position: absolute;
			bottom: 1rem;
			right: 1.5rem;
			font-size: 0.8rem;
			padding: 0.35rem 0.65rem;
			border-radius: 999px;
			background: color-mix(in srgb, CanvasText 15%, Canvas 85%);
			color: color-mix(in srgb, CanvasText 70%, Canvas 30%);
		}
	</style>
</head>
<body>
	<header>
		<div>
			<h1>Hornet Reader Simulator</h1>
			<p class="details">Try the color-guided reading effect and tweak settings without installing the extension.</p>
		</div>
		<span class="badge">Demo only · No Chrome APIs required</span>
	</header>

	<main>
		<section class="panel" aria-labelledby="controls-heading">
			<h2 id="controls-heading">Extension popup preview</h2>
			<form id="controls" autocomplete="off">
				<div class="setting">
					<label>
						<input type="checkbox" id="enabled" />
						Enable Hornet
					</label>
				</div>

				<div class="setting">
					<label for="mode">Visualization mode</label>
					<select id="mode">
						<option value="bidirectional-gradient">Bidirectional gradient (reference)</option>
						<option value="alternating-bands">Alternating background bands</option>
						<option value="focus-window">Dynamic focus window</option>
						<option value="gutter-markers">Gutter markers</option>
						<option value="letter-spacing">Alternating letter spacing</option>
						<option value="font-weight">Alternating font weight</option>
						<option value="underline-overline">Underline / overline rhythm</option>
						<option value="word-chunking">Word chunking groups</option>
						<option value="column-gradient">Vertical column gradient</option>
						<option value="paragraph-gradient">Per-paragraph wash</option>
						<option value="symbolic-overlays">Line-end symbols</option>
						<option value="contrast-dimmer">Dim surrounding lines</option>
						<option value="audio-cadence">Audio cadence metronome</option>
					</select>
				</div>

				<p id="modeDescription"></p>

				<div class="setting" data-control-group="gradient">
					<label for="gradient_size"><span id="gradientSizeLabel">Gradient Size</span> (<span id="gradientSizeValue">50</span>)</label>
					<input type="range" id="gradient_size" min="0" max="100" value="50" />
				</div>

				<div class="setting" data-control-group="color-pair">
					<label for="color1">Color 1</label>
					<input type="color" id="color1" value="#0000FF" />
				</div>

				<div class="setting" data-control-group="color-pair">
					<label for="color2">Color 2</label>
					<input type="color" id="color2" value="#FF0000" />
				</div>

				<div class="setting" data-control-group="color-text">
					<label for="color_text">Text color</label>
					<input type="color" id="color_text" value="#000000" />
				</div>

				<div class="color-samples" aria-hidden="true" data-control-group="color-samples">
					<div id="chip-color1" class="color-chip"></div>
					<div id="chip-color2" class="color-chip"></div>
					<div id="chip-text" class="color-chip"></div>
				</div>

				<div class="setting" style="display:flex; gap:0.75rem; flex-wrap: wrap;">
					<button type="button" id="apply">Apply effect</button>
					<button type="button" id="reset" class="ghost">Reset</button>
				</div>
			</form>
		</section>

		<section class="panel" aria-labelledby="preview-heading">
			<h2 id="preview-heading">Preview article</h2>
			<div class="details">Toggle “Enable Hornet” or use Apply to see how the extension colors live content. Resize the window to test wrap detection.</div>
			<article id="sample" contenteditable="true" spellcheck="false">
				<p>Reading on screens introduces tiny visual frictions&mdash;our eyes can lose track of the start of the next line, especially in dense paragraphs. Color gradients create a subtle bridge between line endings and beginnings so the eye naturally follows the hue transition.</p>
				<p>WaspLine alternates the gradient direction, so the left edge of odd lines and the right edge of even lines receive the strongest color accent. That mirrored pattern makes it easier to jump between lines without searching for your place.</p>
				<p>Use the controls to experiment with gradient length and colors. You can try high-contrast gradients for rapid scanning, or gentle pastel pairs for everyday reading without fatigue. Toggle the effect off to compare the baseline experience.</p>
				<p>Because this is a standalone simulator, you can copy any article text into the preview area. The same line wrap detection logic used in the browser extension powers this demo.</p>
			</article>
		</section>
	</main>

	<footer>
		<p>Tip: paste your own content into the preview article to see how Hornet reacts to different layouts, columns, and fonts.</p>
	</footer>

	<script>
	(function () {
		'use strict';

		function wrapWords(text, before, after, join) {
			const delimiter = join || '';
			return text.split('').map((word) => `${before}${word}${after}`).join(delimiter);
		}

		function wrapWordsInChildElement(node) {
			if (node.nodeName === '#text') {
				const characters = node.textContent.split('');

				for (let i = 0; i < characters.length; i += 1) {
					const char = characters[i];
					if (char.length > 0) {
						const span = node.ownerDocument.createElement('span');
						span.className = 'js-detect-wrap';
						span.innerText = char;
						node.parentNode.insertBefore(span, node);
					}
				}

				node.parentNode.removeChild(node);
			} else if (node.innerText) {
				node.innerHTML = wrapWords(node.innerText, '<span class="js-detect-wrap">', '</span>');
			}
		}

		function wrapWordsInElement(node) {
			if (!node.firstChild) {
				wrapWordsInChildElement(node);
				return;
			}

			const siblings = [];
			let pointer = node.firstChild;
			do {
				siblings.push(pointer);
				pointer = pointer.nextSibling;
			} while (pointer);

			for (let i = 0; i < siblings.length; i += 1) {
				wrapWordsInElement(siblings[i]);
			}
		}

		function getLines(element) {
			wrapWordsInElement(element);

			const spans = element.getElementsByClassName('js-detect-wrap');
			const lines = [];
			let currentLine = [];
			let lastOffset = 0;

			for (let i = 0; i < spans.length; i += 1) {
				const span = spans[i];
				const offset = span.offsetTop + span.getBoundingClientRect().height;

				if (offset === lastOffset) {
					currentLine.push(span);
				} else {
					if (currentLine.length > 0) {
						lines.push(currentLine);
					}

					currentLine = [span];
				}

				lastOffset = offset;
			}

			if (currentLine.length > 0) {
				lines.push(currentLine);
			}

			return lines;
		}

		function lerp(v0, v1, t) {
			return v0 * (1 - t) + v1 * t;
		}

		function clamp01(value) {
			return Math.max(0, Math.min(1, value));
		}

		function hexToRgb(hex) {
			return hex.replace('#', '').match(/.{1,2}/g).map((chunk) => parseInt(chunk, 16));
		}

		function applyGradient(paragraphs, options) {
			const { colors, colorText, gradientSize } = options;
			const baseColor = hexToRgb(colorText);
			let colorIndex = 0;
			let lineNumber = 0;

			for (const paragraph of paragraphs) {
				const lines = getLines(paragraph);

				for (let line of lines) {
					const activeColor = hexToRgb(colors[colorIndex]);
					const isLeft = lineNumber % 2 === 0;
					if (isLeft) {
						line = Array.from(line).reverse();
					}

					const denominator = (line.length * gradientSize) / 50;

					for (let position = 0; position < line.length; position += 1) {
						const span = line[position];
						const t = gradientSize <= 0 ? 0 : clamp01(1 - position / denominator);
						const red = lerp(baseColor[0], activeColor[0], t);
						const green = lerp(baseColor[1], activeColor[1], t);
						const blue = lerp(baseColor[2], activeColor[2], t);
						span.style.color = `rgb(${red | 0}, ${green | 0}, ${blue | 0})`;
					}

					if (!isLeft) {
						colorIndex = (colorIndex + 1) % colors.length;
					}
					lineNumber += 1;
				}
			}
		}

		function hexToRgba(hex, alpha) {
			const [r, g, b] = hexToRgb(hex);
			return `rgba(${r}, ${g}, ${b}, ${alpha})`;
		}

		function computeLines(container) {
			const paragraphs = container.getElementsByTagName('p');
			const sampleRect = container.getBoundingClientRect();
			const lines = [];
			let index = 0;

			for (const paragraph of paragraphs) {
				const lineFragments = getLines(paragraph);

				for (const fragment of lineFragments) {
					if (!fragment.length) {
						continue;
					}

					const spans = fragment.slice();
					const firstRect = spans[0].getBoundingClientRect();
					const lastRect = spans[spans.length - 1].getBoundingClientRect();

					lines.push({
						index,
						spans,
						top: firstRect.top - sampleRect.top + container.scrollTop,
						height: firstRect.height,
						left: firstRect.left - sampleRect.left,
						right: lastRect.right - sampleRect.left,
						text: spans.map((span) => span.innerText).join('')
					});

					index += 1;
				}
			}

			return lines;
		}

		function createOverlay(container, className) {
			const overlay = document.createElement('div');
			overlay.className = className ? `overlay-layer ${className}` : 'overlay-layer';
			container.appendChild(overlay);
			return overlay;
		}

		function resolveLineIndexByY(lines, y) {
			if (!lines.length) {
				return -1;
			}

			let closestIndex = 0;
			let closestDistance = Infinity;

			for (let i = 0; i < lines.length; i += 1) {
				const line = lines[i];
				const start = line.top;
				const end = start + line.height;
				if (y >= start && y <= end) {
					return i;
				}

				const center = start + line.height / 2;
				const distance = Math.abs(y - center);
				if (distance < closestDistance) {
					closestDistance = distance;
					closestIndex = i;
				}
			}

			return closestIndex;
		}

		const modeConfigs = {
			'bidirectional-gradient': {
				description: 'Alternates a left-to-right and right-to-left gradient every line to guide your eyes between line endings and beginnings.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Gradient size', min: 0, max: 100, step: 1, defaultValue: 50 },
				apply: ({ colors, colorText, gradientSize }) => {
					const paragraphs = sample.getElementsByTagName('p');
					applyGradient(paragraphs, { colors, colorText, gradientSize });
				}
			},
			'alternating-bands': {
				description: 'Paints alternating translucent bands behind each line for a rhythm similar to guided reading overlays.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Band intensity', min: 0, max: 100, step: 1, defaultValue: 55 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const overlay = createOverlay(sample);
					const lines = computeLines(sample);
					const intensity = 0.18 + clamp01(gradientSize / 100) * 0.5;

					for (const line of lines) {
						const band = document.createElement('div');
						band.className = 'line-band';
						band.style.top = `${line.top}px`;
						band.style.setProperty('--band-height', `${line.height + 6}px`);
						band.style.background = hexToRgba(colors[line.index % colors.length], intensity);
						overlay.appendChild(band);
					}
				}
			},
			'focus-window': {
				description: 'Adds a soft focus window that tracks your cursor so you can follow one line at a time.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Window height', min: 20, max: 140, step: 5, defaultValue: 60 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const overlay = createOverlay(sample);
					const focusWindow = document.createElement('div');
					focusWindow.className = 'focus-window';
					const alpha = 0.12 + clamp01(gradientSize / 140) * 0.55;
					focusWindow.style.background = `linear-gradient(90deg, ${hexToRgba(colors[0], alpha)} 0%, ${hexToRgba(colors[1], alpha)} 100%)`;
					overlay.appendChild(focusWindow);
					const lines = computeLines(sample);
					if (!lines.length) {
						return () => {};
					}

					let activeIndex = 0;

					function moveTo(index) {
						const line = lines[index];
						focusWindow.style.opacity = '0.85';
						focusWindow.style.top = `${line.top - 4}px`;
						const padding = clamp01(gradientSize / 140) * line.height;
						focusWindow.style.height = `${line.height + padding}px`;
					}

					moveTo(activeIndex);

					const onMouseMove = (event) => {
						const rect = sample.getBoundingClientRect();
						const localY = event.clientY - rect.top + sample.scrollTop;
						const index = resolveLineIndexByY(lines, localY);
						if (index >= 0 && index !== activeIndex) {
							activeIndex = index;
							moveTo(activeIndex);
						}
					};

					const onLeave = () => {
						focusWindow.style.opacity = '0';
					};

					sample.addEventListener('mousemove', onMouseMove);
					sample.addEventListener('mouseleave', onLeave);
					sample.addEventListener('mouseenter', () => moveTo(activeIndex));

					return () => {
						sample.removeEventListener('mousemove', onMouseMove);
						sample.removeEventListener('mouseleave', onLeave);
					};
				}
			},
			'gutter-markers': {
				description: 'Places alternating colored markers in the gutter to anchor each line visually.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Marker size', min: 6, max: 28, step: 1, defaultValue: 14 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const layer = document.createElement('div');
					layer.className = 'gutter-layer';
					sample.appendChild(layer);
					const lines = computeLines(sample);
					const size = gradientSize;

					for (const line of lines) {
						const marker = document.createElement('div');
						marker.className = 'gutter-marker';
						marker.style.width = `${size}px`;
						marker.style.height = `${size}px`;
						marker.style.top = `${line.top + line.height / 2 - size / 2}px`;
						marker.style.background = colors[line.index % colors.length];
						layer.appendChild(marker);
					}
				}
			},
			'letter-spacing': {
				description: 'Alternates letter spacing between lines to change the perceived texture of the paragraph.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Spacing amount', min: 0, max: 80, step: 5, defaultValue: 30 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const lines = computeLines(sample);
					const spacing = (gradientSize / 100) * 0.4;

					for (const line of lines) {
						const spacingValue = line.index % 2 === 0 ? spacing : spacing * 0.25;
						for (const span of line.spans) {
							span.style.letterSpacing = `${spacingValue.toFixed(3)}em`;
							span.style.color = colors[line.index % colors.length];
						}
					}
				}
			},
			'font-weight': {
				description: 'Alternates between heavier and lighter weights to create a pulse through the paragraph.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Weight contrast', min: 0, max: 100, step: 5, defaultValue: 45 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const lines = computeLines(sample);
					const heavy = Math.min(900, 500 + Math.round(gradientSize * 3.5));
					const light = Math.max(200, heavy - 350);

					for (const line of lines) {
						const weight = line.index % 2 === 0 ? heavy : light;
						for (const span of line.spans) {
							span.style.fontWeight = weight;
							span.style.color = colors[line.index % colors.length];
						}
					}
				}
			},
			'underline-overline': {
				description: 'Adds an underline then an overline on alternating lines to mark cadence.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Decoration weight', min: 1, max: 12, step: 1, defaultValue: 4 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const lines = computeLines(sample);
					const thickness = Math.max(1, gradientSize);

					for (const line of lines) {
						const decoration = line.index % 2 === 0 ? 'underline' : 'overline';
						const color = colors[line.index % colors.length];
						for (const span of line.spans) {
							span.style.textDecoration = decoration;
							span.style.textDecorationColor = color;
							span.style.textDecorationThickness = `${thickness / 3}px`;
						}
					}
				}
			},
			'word-chunking': {
				description: 'Groups words into soft capsules to highlight phrasing and natural pauses.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Words per chunk', min: 1, max: 5, step: 1, defaultValue: 3 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const paragraphs = sample.getElementsByTagName('p');
					const chunkSize = Math.max(1, gradientSize);

					for (const paragraph of paragraphs) {
						const tokens = paragraph.textContent.split(/(\s+)/);
						const fragment = document.createDocumentFragment();
						let chunkContent = '';
						let wordsInChunk = 0;
						let chunkIndex = 0;

						function appendChunk(content) {
							if (!content) {
								return;
							}
							const span = document.createElement('span');
							span.className = 'chunk';
							if (chunkIndex % 2 === 0) {
								span.classList.add('chunk-accent');
								span.style.background = hexToRgba(colors[0], 0.25);
							} else {
								span.style.background = hexToRgba(colors[1], 0.2);
							}
							span.textContent = content;
							fragment.appendChild(span);
							chunkIndex += 1;
						}

						for (const token of tokens) {
							if (!token.trim()) {
								if (chunkContent) {
									chunkContent += token;
								} else {
									fragment.appendChild(document.createTextNode(token));
								}
								continue;
							}

							chunkContent += token;
							wordsInChunk += 1;
							if (wordsInChunk >= chunkSize) {
								appendChunk(chunkContent);
								chunkContent = '';
								wordsInChunk = 0;
							}
						}

						appendChunk(chunkContent);
						paragraph.innerHTML = '';
						paragraph.appendChild(fragment);
					}
				}
			},
			'column-gradient': {
				description: 'Adds a narrow gradient column at the start of the text to act like a visual rail.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Column width', min: 0.5, max: 4, step: 0.1, defaultValue: 1.25 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					sample.classList.add('mode-column-gradient');
					sample.style.setProperty('--column-width', `${gradientSize}rem`);
					sample.style.setProperty('--column-color-start', colors[0]);
					sample.style.setProperty('--column-color-end', colors[1]);

					return () => {
						sample.classList.remove('mode-column-gradient');
						sample.style.removeProperty('--column-width');
						sample.style.removeProperty('--column-color-start');
						sample.style.removeProperty('--column-color-end');
					};
				}
			},
			'paragraph-gradient': {
				description: 'Bathes each paragraph in a low-contrast gradient wash to distinguish sections.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Wash strength', min: 0, max: 100, step: 5, defaultValue: 40 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const paragraphs = sample.getElementsByTagName('p');
					const alpha = 0.12 + clamp01(gradientSize / 100) * 0.45;

					for (let i = 0; i < paragraphs.length; i += 1) {
						const paragraph = paragraphs[i];
						const start = colors[i % colors.length];
						const end = colors[(i + 1) % colors.length];
						paragraph.style.background = `linear-gradient(90deg, ${hexToRgba(start, alpha)} 0%, ${hexToRgba(end, alpha * 0.3)} 70%, transparent 100%)`;
						paragraph.style.padding = '0.4rem 0.6rem';
						paragraph.style.marginInline = '-0.6rem';
						paragraph.style.borderRadius = '12px';
					}
				}
			},
			'symbolic-overlays': {
				description: 'Drops subtle symbols in the right gutter so you can anticipate the next line transition.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Symbol size', min: 0.6, max: 1.6, step: 0.05, defaultValue: 0.9 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const layer = document.createElement('div');
					layer.className = 'symbol-layer';
					sample.appendChild(layer);
					const lines = computeLines(sample);
					const symbols = ['◆', '●', '▲', '■', '✶', '○'];

					for (const line of lines) {
						const marker = document.createElement('div');
						marker.className = 'symbol-marker';
						marker.textContent = symbols[line.index % symbols.length];
						marker.style.top = `${line.top + line.height / 2}px`;
						marker.style.transform = 'translateY(-50%)';
						marker.style.color = colors[line.index % colors.length];
						marker.style.fontSize = `${gradientSize}rem`;
						layer.appendChild(marker);
					}
				}
			},
			'contrast-dimmer': {
				description: 'Dims the surrounding lines until you hover near one, keeping your focus locked in place.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Focus sensitivity', min: 10, max: 90, step: 5, defaultValue: 40 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const lines = computeLines(sample);
					let activeIndex = null;

					for (const line of lines) {
						for (const span of line.spans) {
							span.classList.add('dimmed-line');
						}
					}

					const onMove = (event) => {
						const rect = sample.getBoundingClientRect();
						const localY = event.clientY - rect.top + sample.scrollTop;
						const nextIndex = resolveLineIndexByY(lines, localY);
						if (nextIndex < 0) {
							return;
						}

						if (activeIndex !== null && activeIndex !== nextIndex) {
							for (const span of lines[activeIndex].spans) {
								span.classList.remove('active-line');
								span.style.color = colorText;
							}
						}

						activeIndex = nextIndex;
						const tint = clamp01(gradientSize / 100) * 0.6;
						for (const span of lines[activeIndex].spans) {
							span.classList.add('active-line');
							span.style.color = hexToRgba(colors[activeIndex % colors.length], 0.6 + tint);
						}
					};

					const onLeave = () => {
						if (activeIndex === null) {
							return;
						}
						for (const span of lines[activeIndex].spans) {
							span.classList.remove('active-line');
							span.style.color = colorText;
						}
						activeIndex = null;
					};

					sample.addEventListener('mousemove', onMove);
					sample.addEventListener('mouseleave', onLeave);

					return () => {
						sample.removeEventListener('mousemove', onMove);
						sample.removeEventListener('mouseleave', onLeave);
					};
				}
			},
			'audio-cadence': {
				description: 'Simulates a metronome by highlighting each line in sequence with a tempo badge.',
				controls: ['gradient', 'color-pair', 'color-text', 'color-samples'],
				slider: { label: 'Tempo (faster ←→ slower)', min: 20, max: 160, step: 5, defaultValue: 80 },
				apply: ({ colors, colorText, gradientSize }) => {
					sample.style.color = colorText;
					const overlay = createOverlay(sample);
					const indicator = document.createElement('div');
					indicator.className = 'audio-indicator';
					overlay.appendChild(indicator);
					const lines = computeLines(sample);
					if (!lines.length) {
						indicator.textContent = 'No lines detected';
						return () => {};
					}

					let activeIndex = -1;
					const intervalMs = Math.max(350, 1800 - gradientSize * 10);

					function highlightLine(index) {
						if (activeIndex >= 0) {
							for (const span of lines[activeIndex].spans) {
								span.style.background = '';
								span.style.color = colorText;
							}
						}

						activeIndex = index;
						const color = colors[index % colors.length];
						for (const span of lines[index].spans) {
							span.style.background = hexToRgba(color, 0.25);
							span.style.color = color;
						}
						const bpm = Math.round(60000 / intervalMs);
						indicator.textContent = `Tempo ${bpm} bpm · Line ${index + 1}/${lines.length}`;
					}

					let ticker = 0;
					highlightLine(0);
					const timer = setInterval(() => {
						ticker = (ticker + 1) % lines.length;
						highlightLine(ticker);
					}, intervalMs);

					return () => {
						clearInterval(timer);
					};
				}
			}
		};

		function simulateExtension() {
			const controls = document.getElementById('controls');
			const enabled = document.getElementById('enabled');
			const gradientSize = document.getElementById('gradient_size');
			const color1 = document.getElementById('color1');
			const color2 = document.getElementById('color2');
			const colorText = document.getElementById('color_text');
			const modeSelect = document.getElementById('mode');
			const applyButton = document.getElementById('apply');
			const resetButton = document.getElementById('reset');
			const gradientSizeValue = document.getElementById('gradientSizeValue');
			const gradientSizeLabel = document.getElementById('gradientSizeLabel');
			const modeDescription = document.getElementById('modeDescription');
			const sample = document.getElementById('sample');
			const defaultHTML = sample.innerHTML;
			let baselineHTML = defaultHTML;
			const chips = {
				color1: document.getElementById('chip-color1'),
				color2: document.getElementById('chip-color2'),
				text: document.getElementById('chip-text')
			};
			const controlGroups = new Map();
			const sliderValues = {};
			let cleanupCurrentMode = null;
			let visibleControls = new Set();

			for (const node of document.querySelectorAll('[data-control-group]')) {
				const group = node.dataset.controlGroup;
				if (!controlGroups.has(group)) {
					controlGroups.set(group, []);
				}
				controlGroups.get(group).push(node);
			}

			function updateChips() {
				chips.color1.style.background = color1.value;
				chips.color2.style.background = color2.value;
				chips.text.style.background = colorText.value;
				chips.color1.style.display = visibleControls.has('color-pair') ? '' : 'none';
				chips.color2.style.display = visibleControls.has('color-pair') ? '' : 'none';
				chips.text.style.display = visibleControls.has('color-text') ? '' : 'none';
			}

			function resetToBaseline() {
				sample.classList.remove('mode-column-gradient');
				sample.removeAttribute('style');
				sample.innerHTML = baselineHTML;
			}

			function configureControls(modeKey) {
				const config = modeConfigs[modeKey];
				if (!config) {
					return;
				}

				modeDescription.textContent = config.description;
				visibleControls = new Set(config.controls || []);

				for (const [group, nodes] of controlGroups.entries()) {
					const show = visibleControls.has(group);
					for (const node of nodes) {
						node.classList.toggle('hidden', !show);
					}
				}

				const sliderConfig = config.slider;
				if (sliderConfig) {
					gradientSize.classList.remove('hidden');
					gradientSizeLabel.textContent = sliderConfig.label || 'Intensity';
					gradientSize.min = sliderConfig.min;
					gradientSize.max = sliderConfig.max;
					gradientSize.step = sliderConfig.step || 1;
					const stored = sliderValues[modeKey];
					if (stored !== undefined) {
						gradientSize.value = stored;
					} else if (sliderConfig.defaultValue !== undefined) {
						gradientSize.value = sliderConfig.defaultValue;
					}
					gradientSizeValue.textContent = gradientSize.value;
				} else {
					gradientSizeLabel.textContent = 'Intensity';
					gradientSizeValue.textContent = gradientSize.value;
				}

				updateChips();
			}

			function applyCurrentMode() {
				if (!enabled.checked) {
					return;
				}

				if (cleanupCurrentMode) {
					cleanupCurrentMode();
					cleanupCurrentMode = null;
				}

				resetToBaseline();

				const modeKey = modeSelect.value;
				const config = modeConfigs[modeKey];
				if (!config) {
					return;
				}

				const options = {
					sample,
					colors: [color1.value, color2.value],
					colorText: colorText.value,
					gradientSize: Number(gradientSize.value)
				};

				const cleanup = config.apply(options);
				if (typeof cleanup === 'function') {
					cleanupCurrentMode = cleanup;
				}
			}

			function handleToggle() {
				if (enabled.checked) {
					applyButton.disabled = false;
					applyCurrentMode();
				} else {
					applyButton.disabled = true;
					if (cleanupCurrentMode) {
						cleanupCurrentMode();
						cleanupCurrentMode = null;
					}
					resetToBaseline();
				}
			}

			controls.addEventListener('input', (event) => {
				if (event.target === gradientSize) {
					gradientSizeValue.textContent = gradientSize.value;
					sliderValues[modeSelect.value] = Number(gradientSize.value);
				}

				updateChips();

				if (enabled.checked && event.target.matches('input')) {
					applyCurrentMode();
				}
			});

			modeSelect.addEventListener('change', () => {
				configureControls(modeSelect.value);
				if (enabled.checked) {
					applyCurrentMode();
				}
			});

			enabled.addEventListener('change', handleToggle);
			applyButton.addEventListener('click', applyCurrentMode);
			resetButton.addEventListener('click', () => {
				enabled.checked = false;
				baselineHTML = defaultHTML;
				if (cleanupCurrentMode) {
					cleanupCurrentMode();
					cleanupCurrentMode = null;
				}
				handleToggle();
				configureControls(modeSelect.value);
			});

			sample.addEventListener('input', () => {
				if (!enabled.checked) {
					baselineHTML = sample.innerHTML;
				}
			});

			window.addEventListener('resize', () => {
				if (enabled.checked) {
					applyCurrentMode();
				}
			});

			configureControls(modeSelect.value);
			updateChips();
			applyButton.disabled = true;
		}

		simulateExtension();
	})();
	</script>
</body>
</html>
